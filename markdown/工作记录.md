

[TOC]



#  1 **安图ROUTER路由器特殊程序移植迭代需求** 

http://172.16.2.8/biz/feedback-adminView-1243.html 开发[@包海欣](app://desktop.dingtalk.com/web_content/chatbox.html?isFourColumnMode=false#)  测试[@徐艳凤](app://desktop.dingtalk.com/web_content/chatbox.html?isFourColumnMode=false#) （评审时间待定

v7.2.1评审记录http://172.16.2.8/biz/testtask-view-100.html

7.2.3程序[文档-/受控软件资料库 - 禅道](http://172.16.2.8/biz/doc-browse-168-byModule-3059.html)



过滤需求[DOC #4237 安图生物H7920/H8951/H8951S/H8922SV40B、H8922V40A(H8900_APP_V7.2.1_AUTOBIO_190806123201.trx&YF190809-02) - 受控软件资料库 - 禅道](http://172.16.2.8/biz/doc-view-4237.html)

历史需求链接：http://172.16.2.4:8080/browse/PHDCUSTOMERREQ-903



1. 升级到v7.2.1升级，查看相关代码，测试相关功能，

2. 载v7.2.3程序
3. 查看历史修改记录？

转发过滤规则中，
 黑名单： 默认允许数据包转发， 符合名单中“ 丢弃” 规则的数据包不能经过路由器
转发。
 白名单： 默认拒绝数据包转发， 符合名单中“ 接受” 规则的数据包可以经过路由器
转发出去。

白名单：如果时白名单格式，默认拒绝转发，除了名单中permit规则的，只有白名单中permit规则的能拼通

黑名单：如果为黑名单格式，默认接收转发，除了名单中deny规则的，除了黑名单中deny规则的，其他都能拼通。

一个permit规则，在 白名单中：

- 1 IP过滤添加规则后的filter表

![image-20221019113240059](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019113240059.png)

OUTPUT链中的forward_ip_list, 为什么在OUTPUT链中？看错了

![image-20221019113304470](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019113304470.png)

- 2 将ip过滤切换到白名单后，日志出现：

- ![image-20221019114421425](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019114421425.png)

  ![image-20221019114447951](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019114447951.png)

  执行这行代码

  ![image-20221019114615649](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019114615649.png)

调用iptables_init地方有两处

![image-20221019114803025](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019114803025.png)

filter_exit(int signo)

filter_init



*23端口*是telnet的端口

*0端口*是为HTTP（HyperText Transport Protocol)即超文本传输协议开放的，



ip过滤：白名单和黑名单的cli.conf区别，白名单会多一条：

![image-20221019152359214](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019152359214.png)

域名过滤：为白名单时

![image-20221019152600561](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019152600561.png)

​	转为黑名单时不见了deny

![image-20221019152702881](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019152702881.png)



添加域名过滤：

黑名单：

为什么添加到链forward_ip_list了，不应该是forward_domain_list中吗？

![image-20221019153316072](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019153316072.png)

![image-20221019153308458](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019153308458.png)

![image-20221019153345957](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019153345957.png)

白名单：





![image-20221019153414019](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019153414019.png)

iptables表没有变化

iptables_init();初始化这个表  文件找不到？在cli.conf的末尾

![image-20221019164206798](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019164206798.png)

static void filter_init(void) 过滤表的初始化：

清空表，设置默认策略，初始化上表，创建链，将链添加到相应的链中（INPUT等），初始化新建的链，信号？标志



###  自测：同时使用ip过滤和域名过滤功能

设置ip过滤白名单、域名过滤白名单，放行IP地址8.8.8.8和域名www.baidu.com.

![image-20221021093558477](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221021093558477.png)

![image-20221021093607825](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221021093607825.png)

ping 结果: 能拼通8.8.8.8和www.baidu.com，其他地址均不能拼通。

![image-20221021093742678](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221021093742678.png)



![image-20221021094000459](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221021094000459.png)



安图的这个需求 今天整理一份总结文档发我下 注意是要业务与代码实现相结合的总结文档

![image-20221025090842734](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221025090842734.png)



![image-20221025091624533](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221025091624533.png)



V1

![image-20221025112739015](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221025112739015.png)





#  2 **中移物联H8922 V65特殊版开发需求**   飞思达程序移植

8922V65不能用8951板子

飞思达受控：

[DOC #8114 特殊版 飞思达 H8922V65A（H8900_APP_V7.8.0-T1-FSD-V1_2206131120.trx & YF220906-01） - 受控软件资料库 - 禅道](http://172.16.2.8/biz/doc-view-8114.html)

需求链接：[反馈详情 - 禅道](http://172.16.2.8/biz/feedback-adminView-1269.html)

转测试评审：

[TASK #809 H8900_APP_V7.8.0-T1-FSD-V1_2206131120.trx 转测试/H8922 V65 5G Router - 禅道](http://172.16.2.8/biz/testtask-view-809.html)

程序链接：

http://172.16.8.42/router/H8922V65

原始提交：

[提交中移飞思达定制需求代码 (4a891f45) · 提交 · router / H8922V65 · GitLab](http://172.16.8.42/router/H8922V65/commit/4a891f45ac6dce2f9ea08e320bdd47dbdae90f13?expanded=1#3243c3c7612b866b0f686e36088462875d6260eb)

编译： make -j1 V=s

访问地址：https://www.onecyber.cn/dt
账户名：luliteng
密码：test@123

![image-20221024160825762](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221024160825762.png)





提示缺少权限：

![image-20221025083534439](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221025083534439.png)



## MQTT

物联网传输协议，设计用于轻量级的发布/订阅式消息传输，，旨在为低带宽和不稳定的网络环境中的物联网设备提供可靠的网络服务

#### 发布 - 订阅模式

发布 - 订阅模式，我相信接触消息中间件架构的同学都听过，这是一种传统的客户端 - 服务器架构的替代方案，因为一般传统的客户端-服务器是客户端能够直接和服务器进行通信。

但是发布 - 订阅模式 pub/sub就不一样了，发布订阅模式会将发送消息的发布者 publisher与接收消息的订阅者 subscribers进行分离，publisher 与 subscribers 并不会直接通信，他们甚至都不清楚对方是否存在，他们之间的交流由第三方组件 broker 代理。

pub/sub 最重要的方面是 publisher 与 subscriber 的解藕，这种耦合度有下面三个维度：

1、空间解耦

publisher 与 subscriber 并不知道对方的存在，例如不会有 IP 地址和端口的交互，也更不会有消息的交互。

2、时间解藕

publisher 与 subscriber 并不一定需要同时运行。

3、同步 Synchronization 解藕

两个组件的操作比如 publish 和 subscribe 都不会在发布或者接收过程中产生中断。

总之，发布/订阅模式消除了传统客户-服务器之间的直接通信，把通信这个操作交给了 broker 进行代理，并在空间、时间、同步三个维度上进行了解藕。

**事件**驱动是一种编程范式，编程范式是软件工程中的概念，它指的是一种编程方法或者说程序设计方式，比如说面向对象编程和面向过程编程就是一种编程范式，事件驱动中的程序流程会由诸如用户操作（点击鼠标、键盘）、传感器输出或者从其他程序或传递的消息事件决定。事件驱动编程是图形用户界面和其他应用程序比如 Web 中使用的主要范式，这些应用程序能够响应用户输入执行某些操作为中心，这同时也适用于驱动程序的编程

#### 消息过滤

订阅者只接收自己感兴趣的消息



## UCI

UCI主要是一种对底层配置文件处理的一种方法。

用于OpenWrt整个系统的配置集中化。很多后台服务有自己的配置文件，并且配置文件格式都不相同，OpenWrt系统中需要开启各种服务，为了解决配置不兼容的问题，统一采用uci格式的配置文件。

#### UCI的结构

默认访问路径为：/etc/config/下面的配置文件

![image-20221025153606231](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221025153606231.png)

network整个文件的内容对应：配置文件包（package）

![image-20221025154214164](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221025154214164.png)

#### UCI结构的对应结构体

UCI上下文结构体：贯穿查询、更改配置文件全过程

### Mosquitto

Mosquitto是开源(EPL / EDL许可)消息代理

##### 1、库的初始化与清除

- (1）初始化mosquitto库，必须在任何其他mosqtto函数前调用

```c
int mosquitto_lib_init (NULL);
//返回值：
//MOSQ_ERR_SUCCESS：成功。
//MOSQ_ERR_UNKNOWN：在 Windows 上，无法初始化套接字。
```

（2）释放与库关联的资源

```c
int mosquitto_lib_cleanup (NULL);
//返回值：MOSQ_ERR_SUCCESS 总是
```

##### 2、客户端创建与销毁

（1）创建一个新的 mosquitto 客户端实例

```c
struct mosquitto *mosquitto_new(const char *id, bool clean_session, void *obj);
//id：：用作客户端 ID 的字符串。如果为 NULL，将生成一个随机客户端 ID。如果 id 为 NULL，则 clean_session 必须为真。
//clean_session：设置为 true 指示代理在断开连接时清除所有消息和订阅。设置为 false 指示它保留它们，注意，客户端永远不会在断开连接时丢弃自己的传出消息。调用mosquitto_connect或mosquitto_reconnect将导致消息被重新发送。使用mosquitto_reinitialise将客户端重置为其原始状态。如果 id 参数为 NULL，则必须设置为 true。
//obj： 用户指针，将作为参数传递给指定的任何回调。

//返回值：成功则指向struct mosquitto类型的指针。失败时为 NULL。可查询 errno 以确定失败的原因。

```

（2）释放与 mosquitto客户端实例关联的内存

```c
void mosquitto_destroy(struct mosquitto  *mosq);
```

##### 3、用户名和密码

（1）为 mosquitto实例配置用户名和密码。默认情况下，不发送用户名或密码。此函数必须在调用mosquitto_connect之前调用，是否需要调用此函数取决于broker设置了匿名访问。

```c
int mosquitto_username_pw_set(struct  mosquitto  *mosq, const  char  *username, const char  *password);
//mosq：mosquitto实例。
//username：用户名字符串，或 NULL 以禁用身份验证。
//password：密码字符串。当用户名有效时设置为 NULL，则仅发送用户名。
```

##### 4、连接

1）连接到broker(代理)

```c
int mosquitto_connect(struct mosquitto *mosq, const char *host, int port, int keepalive);
//mosq：mosquitto实例。
//host：broker的主机名或 IP 地址。
//port：网络端口，通常是 1883 。
//keepalive：如果在这段时间内（秒数）没有交换其他消息，broker应该向客户端发送 PING 消息。
//返回值：0失败
```

##### 5、发布与订阅

2）订阅一个主题，需等待客户端连接成功后才可订阅，连接断开重连后需要重新订阅，所以订阅一般放在连接回调中

```c
int mosquitto_subscribe(struct mosquitto *mosq, int *mid, const char *sub,int qos);
//mosq：mosquitto实例。
//mid：指向 int 的指针。如果不为 NULL，该函数会将其设置为此特定消息的消息 ID。然后可以将其与 subscribe 回调一起使用，以确定消息何时发送。
//sub：订阅主题。
//qos：服务质量，此订阅请求的服务质量。

```



##### 6 、回调设置

（1）连接成功回调设置

```c
void mosquitto_connect_callback_set(struct mosquitto *mosq, void (*on_connect)(struct mosquitto *, void *, int));
//mosq：mosquitto实例。
//on_connect：回调函数，形式为 void callback(struct mosquitto *mosq, void *obj, int rc)。
	//.mosq：mosquitto 实例。
	//.obj：mosquitto_new中提供的用户数据
	//rc：连接响应的返回码。这些值由使用的MQTT协议版本定义。
void (*on_connect)(struct mosquitto *, void *, int)) 函数指针，参数：struct mosquitto *结构体指针
```

##### 7、循环

（1）libmosquitto必须循环处理一些网络消息，必须经常调用如下函数以保持客户端与broker之间的通信正常，此函数不能在回调中调用。此函数一般不使用，一般使用mosquitto_loop_forever和mosquitto_loop_start

```c
int mosquitto_loop(struct 	mosquitto 	*mosq, int timeout, int max_packets);
//mosq：mosquitto实例。
//timeout：在超时之前等待 select() 调用中的网络活动的最大毫秒数。设置为 0 以立即返回。设置负数以使用默认值 1000 毫秒。
//max_packets：此参数当前未使用，应设置为 1 以便将来兼容。
//返回值：
/*MOSQ_ERR_SUCCESS：关于成功。
MOSQ_ERR_INVAL：如果输入参数无效。
MOSQ_ERR_NOMEM：如果发生内存不足的情况。
MOSQ_ERR_NO_CONN：如果客户端未连接到代理。
MOSQ_ERR_CONN_LOST：如果与代理的连接丢失。
MOSQ_ERR_PROTOCOL：如果与代理通信时出现协议错误。
MOSQ_ERR_ERRNO：如果系统调用返回错误。变量 errno 包含错误代码，即使在 Windows 上也是如此。在Linux下使用 strerror(errno) 或在 Windows 上使用 FormatMessage()获取
*/
```

- 通过http REST接口获取CPE设备鉴权信息

GET https://{接入机地址}:{接入机TLS端口}/cpe?imei=xxxx

{"code":0,"message":"","data":{"deviceId":10000223,"deviceSecret":"MDIxMzliZDFkYjQ4NjY3OTY5NGE=","productId":100043},"referInfo":null}

![image-20221025191333616](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221025191333616.png)

![image-20221025192218376](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221025192218376.png)



res=“products/100043/devices/10000223”

et=2009344000

key ：02139bd1db486679694a

![image-20221025192357022](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221025192357022.png)

version=2018-10-31&res=products%2F100043%2Fdevices%2F10000223&et=20093440000&method=sha1&sign=ccxtJ5d2bLq%2BG6hhwiHaFAWfhrQ%3D

## IPV6

modem获取IPV6获取不到：

天线：要接0

升级恢复默认

IPV4: 32位 4个字节

IPV6：128位 16个字节      * 8



IPv6将整个地址分为8段来表示，每段之间用冒号隔开，每段的长度为16位，表示如下：

　　XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX

IPv6中**每一个段是16位**，**每段共4个X**，其中X使用**4 bit**表示，一个X就表示一个数字或字母，一个完整的地址共128 bit。 而一个X使用4 bit表示，那么XXXX的取值范围就应该从0000 到 FFFF。

一个X4位： 0000 1111 0~15 所以 X的范围 0 ~F





```c
#
# Copyright (C) 2012-2015 OpenWrt.org
#
# This is free software, licensed under the GNU General Public License v2.
# See /LICENSE for more information.
#

include $(TOPDIR)/rules.mk#OpenWrt使用三个makefile的子文件,确立软件包加入Openwrt的方法和方式
#编写软件包的基本信息,这些软件包的开头均以PKG_开头
PKG_NAME:=odhcp6c#软件包的名字
PKG_RELEASE:=15#这个 makefile 的版本

PKG_SOURCE_PROTO:=git
PKG_SOURCE_URL=$(PROJECT_GIT)/project/odhcp6c.git
PKG_SOURCE_DATE:=2018-07-14
PKG_SOURCE_VERSION:=67ae6a71b5762292e114b281d0e329cc24209ae6#软件包的版本，主干分支的版本正是我们要下载的
PKG_MIRROR_HASH:=176b637b3856af0d6bb9c526afbddca4e569ea056fc36fc026345e7e22a6cef5
PKG_MAINTAINER:=Hans Dedecker <dedeckeh@gmail.com>
PKG_LICENSE:=GPL-2.0

include $(INCLUDE_DIR)/package.mk#文件对于软件包为内核时不可缺少
include $(INCLUDE_DIR)/cmake.mk#一般在软件包的基本信息完成后引入

CMAKE_OPTIONS += \
	-DUSE_LIBUBOX=on

ifneq ($(CONFIG_PACKAGE_odhcp6c_ext_cer_id),0)
  CMAKE_OPTIONS += -DEXT_CER_ID=$(CONFIG_PACKAGE_odhcp6c_ext_cer_id)
endif

define Package/odhcp6c
  SECTION:=net
  CATEGORY:=Network
  TITLE:=Embedded DHCPv6-client for OpenWrt
  DEPENDS:=@IPV6 +libubox
endef

define Package/odhcp6c/config
  config PACKAGE_odhcp6c_ext_cer_id
    int "CER-ID Extension ID (0 = disabled)"
    depends on PACKAGE_odhcp6c
    default 0
endef

define Package/odhcp6c/install
	$(INSTALL_DIR) $(1)/usr/sbin/
	$(INSTALL_BIN) $(PKG_BUILD_DIR)/odhcp6c $(1)/usr/sbin/
	$(INSTALL_DIR) $(1)/lib/netifd/proto
	$(INSTALL_BIN) ./files/dhcpv4v6.sh $(1)/lib/netifd/proto/dhcpv4v6.sh
	$(INSTALL_BIN) ./files/dhcpv6.sh $(1)/lib/netifd/proto/dhcpv6.sh
	$(INSTALL_BIN) ./files/dhcpv6.script $(1)/lib/netifd/
endef

$(eval $(call BuildPackage,odhcp6c))

```



待修改文件 ui文件

package/hongdian/ui/hd_ui/patchfile/src/html_lib.c

package/hongdian/ui/hd_ui/patchfile/www/html/net_network_add_module.ht  

package/hongdian/ui/hd_ui/patchfile/www/html/network_dhcp_protocol.ht

package/hongdian/ui/hd_ui/patchfile/www/html/network_dhcpv4v6_protocol.ht  此文件没有源文件

package/hongdian/ui/hd_ui/patchfile/www/html/network_dhcpv6_protocol.ht

package/hongdian/ui/hd_ui/patchfile/www/html/network_static_protocol.ht

package/hongdian/ui/hd_ui/patchfile/www/html/status_main_list_module.ht

package/hongdian/ui/hd_ui/patchfile/www/js/common.js





package/network/config/netifd/patchfile/device.c

package/network/config/netifd/patchfile/interface-ip.c

package/network/config/netifd/patchfile/interface-ip.h

package/network/config/netifd/patchfile/wireless.c

package/network/ipv6/odhcp6c/files/dhcpv4v6.sh  此文件没有源文件
